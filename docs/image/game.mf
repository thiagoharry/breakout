numeric size, hsize, control, sound, text_size;
size = hsize = 100;
control = 0; % External program control player setting this variable
sound = 0; % We inform external program which sound should be played
text_size = 42;

numeric _player_width, _player_height, _player_offset, _player_position, _player_speed;
_player_position = 0.5;
_player_width = 0.01583;
_player_height = 0.06203;
_player_offset = 0.10817;
_player_speed = 0.00001;

pair _ball_position, _ball_speed;
numeric _ball_size, _ball_speed_multiplier, _ball_trail_size;
path _ball_trail;
_ball_size = 0.25*_player_height;
_ball_position = (0.5, 0.5);
_ball_speed = (-0.01, 0.00) rotated (2*normaldeviate);
_ball_speed_multiplier = 1.106;
% Controls the trailing:
_ball_trail_size = 10;
_ball_trail = _ball_position;

numeric _wall_height, _wall_width, _wall_offset;
_wall_height = 0.02091;
_wall_width = 0.0343;
_wall_offset = 0.11345;

numeric _brick_width, _brick_height;
_brick_width = 0.01847;
_brick_height = 0.068441;

numeric _brick_row_offset, _bricks_per_row;
_brick_row_offset = 0.6121;

boolean _need_initialize;
_need_initialize = true;

path _brick_state;
_brick_state = (0, 0);

numeric _number_of_hits;
boolean _hit_orange, _hit_red;
_number_of_hits = 0;
_hit_orange = _hit_red = false;

% Screen
beginchar("S", hsize, size, 0);
  % Filling screen black:
  pickup pensquare xscaled w yscaled h;
  pickcolor (0, 0, 0, 1);
  draw (w/2, h/2);
  sound = 0;
  % Initializing (setting brick status and position):
  if _need_initialize:
    numeric i, j, y, x, spacing;
    _bricks_per_row = floor((1-2*_wall_height)/_brick_height);
    spacing = 1 - 2*_wall_height - _bricks_per_row * _brick_height;
    spacing = spacing / (_bricks_per_row+1);
    for i = 8 step -1 until 1:
      x = _brick_row_offset + (i-1) * _brick_width;
      for j = _bricks_per_row step -1 until 1:
	y = (j-1) * (_brick_height+spacing)+0.5*_brick_height+spacing+_wall_height;
	_brick_state = (1, 1)..controls (x, y) .. _brick_state;
      endfor
    endfor
    _need_initialize = false;
  fi
  % Moving player:
  if control > 0:
    if _player_position < (1-_wall_height-0.5*_player_height):
      _player_position = _player_position + _player_speed*h;
      if _player_position > (1-_wall_height-0.5*_player_height):
	_player_position = (1-_wall_height-0.5*_player_height);
      fi
    fi
    control = 0;
  elseif control < 0:
    if _player_position > (_wall_height+0.5*_player_height):
      _player_position = _player_position - _player_speed*h;
      if _player_position < (_wall_height+0.5*_player_height):
	_player_position = _wall_height+0.5*_player_height;
      fi
    fi
    control = 0;
  fi
  % Ball trailing:
  if ((length _ball_trail) < _ball_trail_size):
    _ball_trail = _ball_trail -- _ball_position;
  else:
    _ball_trail = (subpath (1, _ball_trail_size) of _ball_trail) -- _ball_position;
  fi
  % Ball
  _ball_position = _ball_position + _ball_speed;
  % Collision with lateral walls:
  if (ypart _ball_position > 1-_wall_height - 0.5*_ball_size) and (ypart _ball_speed > 0):
    _ball_speed = (xpart _ball_speed, -ypart _ball_speed);
  elseif (ypart _ball_position < _wall_height + 0.5*_ball_size) and (ypart _ball_speed < 0):
    _ball_speed = (xpart _ball_speed, -ypart _ball_speed);
  fi
  % Collision with player
  if ((xpart _ball_position) < (_player_offset+0.5*_player_width+0.5*_ball_size*(h/w))) and
    ((xpart _ball_position) > (_player_offset-0.5*_player_width)) and
    (xpart _ball_speed < 0):
    numeric dist;
    dist = length ((ypart _ball_position) - _player_position);
    if (dist <= (0.5*_player_height+0.5*_ball_size)):
      if (ypart _ball_position > _player_position):
	_ball_speed = (length _ball_speed, 0) rotated ((dist/(2.5/58))*45);
      else:
	_ball_speed = (length _ball_speed, 0) rotated ((dist/(2.5/58))*-45);
      fi
      _ball_position = (_player_offset+0.5*_player_width+0.5*_ball_size*(h/w),
	  ypart _ball_position);
    fi
  % Collision with back wall
  elseif ((xpart _ball_position) >= (1-_wall_offset-0.5*_wall_width-0.5*_ball_size*(h/w)))
    and (xpart _ball_speed > 0):
      _ball_position = (1-_wall_offset-0.5*_wall_width-0.5*_ball_size*(h/w),
	ypart _ball_position);
    _ball_speed = (-xpart _ball_speed, ypart _ball_speed);
  fi
  % Collision with bricks:
  numeric i, total_bricks;
  total_bricks = 8*_bricks_per_row;
  for i = 0 step 1 until total_bricks-1:
    if xpart point i of _brick_state = 1:
      pair brick_coordinate;
      brick_coordinate= postcontrol i of _brick_state;
      if xpart _ball_position > (xpart brick_coordinate) - 0.5 * (_brick_width + _ball_size):
	if xpart _ball_position < (xpart brick_coordinate) + 0.5 * (_brick_width + _ball_size):
	  if ypart _ball_position > (ypart brick_coordinate) - 0.5 * (_brick_height + _ball_size):
	    if ypart _ball_position < (ypart brick_coordinate) + 0.5 * (_brick_height + _ball_size):
	      if i = 0:
		_brick_state = (0,0) .. controls brick_coordinate .. subpath (1, total_bricks) of _brick_state;
	      elseif  i = total_bricks-1:
		_brick_state = (subpath (0, i-1) of _brick_state) .. controls (postcontrol (i-1) of _brick_state) .. (0, 0) .. controls brick_coordinate .. (0, 0);
	      else:
		_brick_state =  (subpath (0, i-1) of _brick_state) .. controls (postcontrol (i-1) of _brick_state) .. (0, 0) .. controls brick_coordinate .. (subpath (i+1, total_bricks) of _brick_state);
	      fi
	      boolean changed_speed;
	      changed_speed = false;
	      if (ypart _ball_position > ypart brick_coordinate - _brick_height) and
		(ypart _ball_position < ypart brick_coordinate + _brick_height):
		  _ball_speed = (-xpart _ball_speed, ypart _ball_speed);
		changed_speed = true;
	      elseif (xpart _ball_position > xpart brick_coordinate - _brick_width) and
		(xpart _ball_position < xpart brick_coordinate + _brick_width):
		  _ball_speed = (xpart _ball_speed, -ypart _ball_speed);
		changed_speed = true;
	      fi
	      if not changed_speed:
		% Collision in unexpected angles or if ball is too fast and
		% is confusing our detection:
	       	_ball_speed = _ball_speed rotated 180;
	      fi
	      % Adding a grain of chaos:
	      _ball_speed = _ball_speed rotated (0.5*normaldeviate);
	      _number_of_hits = _number_of_hits + 1;
	      if _number_of_hits = 4:
		_ball_speed = _ball_speed_multiplier * _ball_speed;
	      elseif _number_of_hits = 12:
		_ball_speed = _ball_speed_multiplier * _ball_speed;
	      fi
	      if not _hit_orange and
		((i / _bricks_per_row = 4) or (i / _bricks_per_row = 5)):
		  _ball_speed = _ball_speed_multiplier * _ball_speed;
		_hit_orange = true;
	      fi
	      if not _hit_red and
		((i / _bricks_per_row = 4) or (i / _bricks_per_row = 5)):
		  _ball_speed = _ball_speed_multiplier * _ball_speed;
		_hit_red = true;
	      fi
	      sound = 1;
	      i = total_bricks-1; % Equivalent to 'break' in other languages
	    fi
	  fi
	fi
      fi
    fi
  endfor
  % Drawing walls
  pickcolor (0.8, 0.8, 0.8, 1);
  pickup pensquare xscaled w yscaled _wall_height*h;
  draw bot rt (0,h);
  draw top rt (0,0);
  pickup pensquare xscaled _wall_width*w yscaled h;
  draw bot ((1-_wall_offset)*w, h);
  % Drawing player
  pickup pensquare xscaled _player_width*w yscaled _player_height*h;
  pickcolor (0.03921, 0.5215, 0.76078, 1);
  draw (_player_offset*w, _player_position*h);
  % Drawing ball
  numeric count, trail_size, trail_intensity;
  trail_size = 0.62*_ball_size;
  trail_intensity = 1;
  for count = _ball_trail_size step -1 until 1:
    pickcolor (trail_intensity, trail_intensity, 0, 1);
    pickup pencircle xscaled trail_size*h yscaled trail_size*h;
    trail_size = trail_size  - 0.62*(_ball_size/_ball_trail_size);
    draw ((point count of _ball_trail)--(point (count-1) of _ball_trail))
      xscaled w yscaled h;
    trail_intensity = trail_intensity - (1/_ball_trail_size);
  endfor
  pickup pencircle xscaled _ball_size*h yscaled _ball_size*h;
  pickcolor (0.8, 0.8, 0.8, 1);
  draw _ball_position xscaled w yscaled h;
  % Drawing  bricks
  numeric offset, current_brick;
  current_brick = 0;
  offset = _brick_row_offset;
  for count = 1 step 1 until _bricks_per_row:
    if xpart point current_brick of _brick_state = 1:
      renderchar "B" between
	((postcontrol current_brick of _brick_state) -
	  (0.5*_brick_width, 0.5*_brick_height)) xscaled w yscaled h and
	((postcontrol current_brick of _brick_state) +
	  (0.5*_brick_width, 0.5*_brick_height)) xscaled w yscaled h;
    fi
    current_brick = current_brick + 1;
  endfor
  offset = offset + _brick_width;
  for count = 1 step 1 until _bricks_per_row:
    if xpart point current_brick of _brick_state = 1:
      renderchar "B" between
	((postcontrol current_brick of _brick_state) -
	  (0.5*_brick_width, 0.5*_brick_height)) xscaled w yscaled h and
	((postcontrol current_brick of _brick_state) +
	  (0.5*_brick_width, 0.5*_brick_height)) xscaled w yscaled h;
    fi
    current_brick = current_brick + 1;
  endfor
  offset = offset + _brick_width;
  for count = 1 step 1 until _bricks_per_row:
    if xpart point current_brick of _brick_state = 1:
      renderchar "C" between
	((postcontrol current_brick of _brick_state) -
	  (0.5*_brick_width, 0.5*_brick_height)) xscaled w yscaled h and
	((postcontrol current_brick of _brick_state) +
	  (0.5*_brick_width, 0.5*_brick_height)) xscaled w yscaled h;
    fi
    current_brick = current_brick + 1;
  endfor
  offset = offset + _brick_width;
  for count = 1 step 1 until _bricks_per_row:
    if xpart point current_brick of _brick_state = 1:
      renderchar "C" between
	((postcontrol current_brick of _brick_state) -
	  (0.5*_brick_width, 0.5*_brick_height)) xscaled w yscaled h and
	((postcontrol current_brick of _brick_state) +
	  (0.5*_brick_width, 0.5*_brick_height)) xscaled w yscaled h;
    fi
    current_brick = current_brick + 1;
  endfor
  offset = offset + _brick_width;
  for count = 1 step 1 until _bricks_per_row:
    if xpart point current_brick of _brick_state = 1:
      renderchar "D" between
	((postcontrol current_brick of _brick_state) -
	  (0.5*_brick_width, 0.5*_brick_height)) xscaled w yscaled h and
	((postcontrol current_brick of _brick_state) +
	  (0.5*_brick_width, 0.5*_brick_height)) xscaled w yscaled h;
    fi
    current_brick = current_brick + 1;
  endfor
  offset = offset + _brick_width;
  for count = 1 step 1 until _bricks_per_row:
    if xpart point current_brick of _brick_state = 1:
      renderchar "D" between
	((postcontrol current_brick of _brick_state) -
	  (0.5*_brick_width, 0.5*_brick_height)) xscaled w yscaled h and
	((postcontrol current_brick of _brick_state) +
	  (0.5*_brick_width, 0.5*_brick_height)) xscaled w yscaled h;
    fi
    current_brick = current_brick + 1;
  endfor
  offset = offset + _brick_width;
  for count = 1 step 1 until _bricks_per_row:
    if xpart point current_brick of _brick_state = 1:
      renderchar "E" between
	((postcontrol current_brick of _brick_state) -
	  (0.5*_brick_width, 0.5*_brick_height)) xscaled w yscaled h and
	((postcontrol current_brick of _brick_state) +
	  (0.5*_brick_width, 0.5*_brick_height)) xscaled w yscaled h;
    fi
    current_brick = current_brick + 1;
  endfor
  offset = offset + _brick_width;
  for count = 1 step 1 until _bricks_per_row:
    if xpart point current_brick of _brick_state = 1:
      renderchar "E" between
	((postcontrol current_brick of _brick_state) -
	  (0.5*_brick_width, 0.5*_brick_height)) xscaled w yscaled h and
	((postcontrol current_brick of _brick_state) +
	  (0.5*_brick_width, 0.5*_brick_height)) xscaled w yscaled h;
    fi
    current_brick = current_brick + 1;
  endfor
  if xpart _ball_position < 0: % Checking defeat contition
    pair position;
    % Print defeat message
    position = (1.5*(_player_offset+_player_width)*w, h/2);
    renderchar "d" between
      (position - (0.275*text_size*pt, 0.3335*text_size*pt))
      and (position + (0.275*text_size*pt, 0.3335*text_size*pt));
    position = position + (0.55*text_size*pt+4*pt, 0);
    renderchar "e" between
      (position - (0.2275*text_size*pt, 0.334*text_size*pt))
      and (position + (0.2275*text_size*pt, 0.334*text_size*pt));
    position = position + (0.455*text_size*pt+4*pt, 0);
    renderchar "r" between
      (position - (0.2565*text_size*pt, 0.334*text_size*pt))
      and (position + (0.2565*text_size*pt, 0.334*text_size*pt));
    position = position + (0.513*text_size*pt+4*pt, 0);
    renderchar "r" between
      (position - (0.2565*text_size*pt, 0.334*text_size*pt))
      and (position + (0.2565*text_size*pt, 0.334*text_size*pt));
    position = position + (0.513*text_size*pt+4*pt, 0);
    renderchar "o" between
      (position - (0.315*text_size*pt, 0.34*text_size*pt))
      and (position + (0.310*text_size*pt, 0.34*text_size*pt));
    position = position + (0.63*text_size*pt, 0);
    renderchar "t" between
      (position - (0.27*text_size*pt, 0.334*text_size*pt))
      and (position + (0.27*text_size*pt, 0.334*text_size*pt));
    position = position + (0.54*text_size*pt, 0);
    renderchar "a" between
      (position - (0.304*text_size*pt, 0.335*text_size*pt))
      and (position + (0.304*text_size*pt, 0.335*text_size*pt));
    position = position + (0.608*text_size*pt, 0);
   renderchar "!" between
      (position - (0.065*text_size*pt, 0.3335*text_size*pt))
      and (position + (0.065*text_size*pt, 0.3335*text_size*pt));
  elseif _number_of_hits = _bricks_per_row * 8: % Player won
    pair position;
    position = (1.5*(_player_offset+_player_width)*w, h/2);
    renderchar "v" between
      (position - (0.285*text_size*pt, 0.334*text_size*pt))
      and (position + (0.285*text_size*pt, 0.334*text_size*pt));
    position = position + (0.57*text_size*pt, 0);
    renderchar "i" between
      (position - (0.1415*text_size*pt, 0.334*text_size*pt))
      and (position + (0.1415*text_size*pt, 0.334*text_size*pt));
    position = position + (0.283*text_size*pt+7*pt, 0);
    renderchar "t" between
      (position - (0.27*text_size*pt, 0.334*text_size*pt))
      and (position + (0.27*text_size*pt, 0.334*text_size*pt));
    position = position + (0.54*text_size*pt+3*pt, 0);
    renderchar "o" between
      (position - (0.315*text_size*pt, 0.34*text_size*pt))
      and (position + (0.310*text_size*pt, 0.34*text_size*pt));
    position = position + (0.63*text_size*pt+3*pt, 0);
    renderchar "r" between
      (position - (0.2565*text_size*pt, 0.334*text_size*pt))
      and (position + (0.2565*text_size*pt, 0.334*text_size*pt));
    position = position + (0.513*text_size*pt-2*pt, 0);
    renderchar "i" between
      (position - (0.1415*text_size*pt, 0.334*text_size*pt))
      and (position + (0.1415*text_size*pt, 0.334*text_size*pt));
    position = position + (0.283*text_size*pt+9*pt, 0);
    renderchar "a" between
      (position - (0.304*text_size*pt, 0.335*text_size*pt))
      and (position + (0.304*text_size*pt, 0.335*text_size*pt));
    position = position + (0.608*text_size*pt+3*pt, 0);
    renderchar "!" between
      (position - (0.065*text_size*pt, 0.3335*text_size*pt))
      and (position + (0.065*text_size*pt, 0.3335*text_size*pt));
  else:
    shipit; % Continue ther game
  fi
endchar;

% Brick 1
beginchar("B", _brick_width*hsize, _brick_height*size, 0);
  pickup pensquare xscaled w yscaled h;
  pickcolor (0.7608, 0.7608, 0.1608, 1);
  draw (w/2, h/2);
  pickup pensquare;
  pickcolor (color_r/2, color_g/2, color_b/2, 1);
  draw rt top(0, 0)--rt bot(0, h)--lft bot (w, h)--lft top (w, 0)--cycle;
endchar;

% Brick 2
beginchar("C", _brick_width*hsize, _brick_height*size, 0);
  pickcolor (0.03922, 0.5216, 0.2, 1);
  pickup pensquare xscaled w yscaled h;
  draw (w/2, h/2);
  pickup pensquare;
  pickcolor (color_r/2, color_g/2, color_b/2, 1);
  draw rt top(0, 0)--rt bot(0, h)--lft bot (w, h)--lft top (w, 0)--cycle;
endchar;

% Brick 3
beginchar("D", _brick_width*hsize, _brick_height*size, 0);
  pickcolor (0.7607, 0.5216, 0.03921, 1);
  pickup pensquare xscaled w yscaled h;
  draw (w/2, h/2);
  pickup pensquare;
  pickcolor (color_r/2, color_g/2, color_b/2, 1);
  draw rt top(0, 0)--rt bot(0, h)--lft bot (w, h)--lft top (w, 0)--cycle;
endchar;

% Brick 4
beginchar("E", _brick_width*hsize, _brick_height*size, 0);
  pickcolor (0.63921, 0.11764, 0.03921, 1);
  pickup pensquare xscaled w yscaled h;
  draw (w/2, h/2);
  pickup pensquare;
  pickcolor (color_r/2, color_g/2, color_b/2, 1);
  draw rt top(0, 0)--rt bot(0, h)--lft bot (w, h)--lft top (w, 0)--cycle;
endchar;


%Letter 'D'
beginchar("d", 0.55*text_size*pt, 0.667*text_size*pt, 0);
  numeric pen_width, pen_height;
  pen_width = 0.141*h;
  pen_height = 0.118*h;
  pickcolor(1, 1, 1, 1);
  pickup pencircle xscaled pen_width yscaled pen_height;
  pair p1, p2;
  p1 = rt (0, 0);
  p2 = rt (0, h);
  draw p1--p2;
  pair pp1, pp2, p3, p4;
  pp1 = (pen_height/(2*h))[p1, p2];
  pp2 = ((2*h-pen_height)/(2*h))[p1, p2];
  p3 = top (0.331*w, 0);
  p4 = bot (0.331*w, h);
  draw pp1--p3;
  draw pp2--p4;
  pair pp4, pp3, p5;
  pp3 = (0.654*w, 0.106*h);
  pp4 = (0.654*w, 0.894*h);
  p5 = lft (w, 0.501*h);
  draw p4{1, 0}..pp4..{0, -1}p5..pp3..{-1, 0}p3;
endchar;
% Letter 'E'
beginchar("e", 0.455*text_size*pt, 0.668*text_size*pt, 0);
  numeric pen_size;
  pair p1, p2;
  pen_size = 0.141*h;
  p1 = (0, 0);
  p2 = (0, h);
  pickcolor(1, 1, 1, 1);
  pickup pencircle scaled pen_size;
  draw rt p1--rt p2;
  pickup pensquare scaled (pen_size*0.87);
  pair p3;
  p3 = top lft (1w, 0);
  draw top rt p1--p3;
  draw bot rt p2--bot lft (w, h);
  pair p4;
  p4 = lft (0.781*w, 0.515*h);
  draw (0.515[rt p1, rt p2]) -- p4;
endchar;
% Letter 'P'
beginchar("P", 0.489*text_size*pt, 0.667*text_size*pt, 0);
  numeric pen_width, pen_height, ratio, ang;
  pen_width = 0.137*h;
  pen_height = 0.13*h;
  ratio = 0.465; % Ratio between 'P' leg and leg+head
  ang = 0;
  % CONTROL POINTS
  pickcolor(1, 1, 1, 1);
  pickup pencircle xscaled pen_width yscaled pen_height;
  pair p1, p2, p2b, p3, p4, p5, p6;
  p1 = (pen_width/2, 0);    % 'P' bottom point
  p2 = (pen_width/2  + h * sind ang, h);    % 'P' upper left point
  p2b = (1.0-0.5*(pen_height/h))[p1, p2];
  p3 = (0.6*w, h-(pen_height/2)); % uppermost rightmost point in horizontal line
  p4 = ratio[p1, p2];       % Point where lower part of 'P' head split from leg
  p5 = (0.6*w, ratio*h); % lower rightmost point in horizontal line
  p6 = lft (w, ypart(0.5[p5, p3]));
  draw p1--p2;
  draw bot p2 -- p3;
  draw p4 -- p5;
  draw p5{1, 0}..{0, 1}p6..{-1, 0}p3;
endchar;
% Letter 'R'
beginchar("r", 0.513*text_size*pt, 0.668*text_size*pt, 0);
  numeric ratio, ratio_leg, pen_width, ratio_leg2;
  ratio = 0.95;
  ratio_leg = 0.465; % Ratio between 'P' leg and leg+head
  ratio_leg2 = 0.45 * ratio;
  pen_width = 0.137*h;
  % CONTROL POINTS
  pair p1, p2;
  p1 = (ratio_leg2*w, ratio_leg*h);
  p2 = (w - pen_width/2, 0);
  % RENDERING:
  pickcolor(1, 1, 1, 1);
  pickup pensquare xscaled pen_width;
  renderchar "P" between (0, 0) and (ratio*w, h);
  draw p1--p2;
endchar;
% Letter 'O'
beginchar("o", 0.63*text_size*pt, 0.68*text_size*pt, 0);
  pickcolor(1, 1, 1, 1);
  pickup pencircle xscaled (0.139*h) yscaled (0.114*h);
  pair p1, p2, p3, p4;
  p1 = bot (0.5*w, h);
  p2 = rt (0, 0.5*h);
  p3 = top (0.5*w, 0);
  p4 = lft (w, 0.5*h);
  draw p1{-1, 0}..p2{0, -1}..p3{1, 0}..p4{0, 1}..cycle;
endchar;
% Letter 'T'
beginchar("t", 0.54*text_size*pt, 0.668*size*pt, 0);
  numeric pen_width, pen_height, italic_shift;
  pen_width = 0.00539*h;
  pen_height = 0.12*h;
  % CONTROL POINTS:
  pair p1, p2, p3, p4;
  p1 = (0, h-(pen_height/2));
  p2 = (w, h-(pen_height/2));
  p3 = (w/2, h-(pen_height));
  p4 = (w/2, 0);
  % RENDERING:
  pickcolor(1, 1, 1, 1);
  pickup pensquare xscaled pen_width yscaled pen_height;
  draw rt p1 -- lft p2;
   %pickup pensquare xscaled pen_width;
  draw p3 -- p4;

endchar;
% Letter 'A'
beginchar("a", 0.608*text_size*pt, 0.67*text_size*pt, 0);
  numeric pen_width, pen_height;
  pen_width = 0.13*h;
  pen_height = 0.121*h;
  pickcolor(1, 1, 1, 1);
  pickup pencircle xscaled pen_width yscaled pen_height;
  pair p1, p2, p3, p4, p5;
  numeric basis, slant;
  basis = 0.277;
  slant = 0.5;
  p1 = rt (0, 0);
  p2 = (slant*w, h);
  p3 = lft (w, 0);
  p4 = basis[p1, p2];
  p5 = basis[p3, p2];
  draw p1--p2--p3;
  pickup pencircle xscaled pen_width yscaled pen_height;
  draw p4--p5;
  pair t1, t2, t3;
  pen triangle_pen;
  t1 = ((xpart p4)+pen_width/2+0.03*w, (ypart p4)+pen_height/2);
  t2 = ((xpart p5)-pen_width/2-0.03*w, (ypart p5)+pen_height/2);
  t3 = (0, 0.84*h);
  triangle_pen = makepen(t1--t2--t3--cycle);
  pickup triangle_pen;
  %erase (0, 0);
endchar;
% Glyph '!':
beginchar("!", 0.13*text_size*pt, 0.667*text_size*pt, 0.012 * text_size * pt);
  numeric circle_diameter;
  % Drawing dot
  circle_diameter = 0.192* h;
  pickcolor (1, 1, 1, 1);
  pickup pencircle scaled circle_diameter;
  draw (top rt (0, -d));
  % Drawing body
  pen body;
  pair p1, p2, p3, p4, p5, p6;
  p1 = (circle_diameter/2-0.033*h, circle_diameter-d+0.125*h);
  p2 = (circle_diameter/2+0.033*h, circle_diameter-d+0.125*h);
  p3 = (circle_diameter/2-0.06*h, circle_diameter-d+0.55*h);
  p4 = (circle_diameter/2+0.06*h, circle_diameter-d+0.55*h);
  p5 = (circle_diameter/2-0.06*h, h);
  p6 = (circle_diameter/2+0.06*h, h);
  body = makepen (p1--p2--p4--p6--p5--p3--cycle);
  pickup body;
  draw (0, 0);
endchar;
% Letter 'v':
beginchar("v", 0.57*text_size*pt, 0.668*text_size*pt, 0);
  % PARAMETERS:
  numeric pen_width, spread, basis_position;
  pen_width = 0.15*h;
  spread = 0.007*w;
  basis_position = 0.5*w;
  % CONTROL POINTS
  pair p1, p2a, p2b, p3;
  p1 = (pen_width/2, h);
  p2a = (basis_position - spread, 0);
  p2b = (basis_position + spread, 0);
  p3 = (w - pen_width/2, h);
  % RENDERING:
  pickcolor (1, 1, 1, 1);
  pickup pensquare xscaled pen_width;
  draw p1--p2a;
  draw p2b--p3;
endchar;
% Letter 'I'
beginchar("i", 0.283*text_size*pt, 0.668*text_size*pt, 0);
  pickcolor (1, 1, 1, 1);
  pickup pencircle scaled 0.141*h;
  pair p1, p2;
  p1 = (0.5*w, 0);
  p2 = (0.5*w, h);
  draw p1--p2;
  pickup pensquare scaled (0.12*h);
  draw top rt (0, 0) -- top lft (w, 0);
  draw bot rt (0, h) -- bot lft (w, h);
endchar;
